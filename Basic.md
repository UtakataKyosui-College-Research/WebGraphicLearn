## WebGL2について

- WebGLはあくまでピクセル描画エンジンだよ
    - 与えたコードによって、線・点・三角形を描画するよ
    - だから何か描画したい時は、点・線・三角形を使用したコードを追加してね
- WebGLはGPU上で動作する
    - そのため、GPUで動作するコードを必要とする
    - 頂点シェーダとフラグメントシェーダと呼ばれる2つの関数が必要
    - GLSLという厳密に型がついているC/C++ような言語で書かれている
    - その2つを組みあわせたものを便宜上プログラムと呼称する
- 頂点シェーダの役割は頂点の位置計算
    -頂点シェーダの結果で点・線・三角形を含む様々な種類のプリミティブを描く
    - プリミティブ描画の際にフラグメントシェーダが呼び出される
    - フラグメントシェーダの役割は、描画されるプリミティブの各ピクセルごとの色計算をする
- `gl.drawArrays`または`gl.drawElements`を呼び出してGPU上でシェーダを実行する
- シェーダに渡したいデータはGPU上にアップロードが必要
    - シェーダがデータを受け取る方法は4つある
        1. 属性、バッファ、頂点配列
            - バッファ
                - GPUにアップロードするバイナリデータ配列
                - 通常は位置や法線、テクスチャ座標、頂点色が含まれる
            - 属性
                - バッファからデータを取り出し、頂点シェーダに与える設定
                - あるバッファに位置ごとに特定ビットの数字が入っているとして、属性に「どのバッファから位置を取り出すか」「開始位置がバッファ内のどのオフセットであるか」「一つの位置から次の位置への取得バイト数」を伝えられる。
                - バッファから自由にデータ取得というのは不可能だが、頂点シェーダを呼び出す回数を設定し、呼び出すごとに次のデータをバッファから読むと属性にそのデータが入る感じ。
            - 頂点配列
                - 属性の状態、どのバッファを使うか、バッファからどのようにデータを引き出すかなどを集約している
        2. ユニフォーム
            - シェーダプログラムの実行前に設定するグローバルな変数
        3. テクスチャ
            - シェーダプログラムで自由に読み込めるデータ配列、画像データをよく入れるが、そもそもはデータ配列なんで、色以外のデータを入れてもかまわない
        4. ヴァイリング
            - 頂点シェーダからフラグメントシェーダびにデータを渡す方法。レンダリングされるデータによって、頂点シェーダでヴァイリングに設定する値は異なり、フラグメントシェーダ実行中に補完される
        
## WebGL2 HelloWorld
- WebGLは2つだけ関心ごとがある
    - クリップ空間と色
    - この２つをWebGLに渡すのがコーダーの役目
        - そのためにシェーダを用意する
        - クリップ空間の頂点座標を与える頂点シェーダと、色を与えるフラグメントシェーダ
        - Canvasサイズに関係なく、クリップ空間の頂点座標は常に`~1 ～ +1`になる。
- 頂点シェーダのコード例
```glsl
in vec4 a_position;

void main() {
    gl_Position = a_position;
}
```

- 実際には、`positionBuffer`をバイナリデータに変換する必要があり、バッファからデータを取り出すための計算とは少し異なる。

- フラグメントシェーダが必要

```glsl
out vec4 outColor;

void main(){
    outColor = vec4(1,0,0.5,1);
}
```

- フラグメントシェーダの出力として、outColorを宣言した。outColorの値について、各引数はRGBAを意味している。

### シェーダコンパイルについて
とりあえず、シェーダプログラムを文字列として変数に格納する。

---

いったんここまで
続きは[ここ](https://webgl2fundamentals.org/webgl/lessons/ja/webgl-fundamentals.html)から参照して、写経しながら学ぶ

---